#' Build a krpcr smoother
#'
#' blurb here
#' Note that the usual \code{k} argument to \code{\link{s}} will set the projection dimension.
#'
#' @aliases krpcr smooth.construct.krpcr.smooth.spec
#' @export
#' @import mgcv
#'
#' @param object a smooth specification object, usually generated by a term \code{s(...,bs="krpcr",...)}. Note that \code{xt} object is needed, see Details, below.
#' @param data a list containing just the data (including any \code{by} variable) required by this term, with names corresponding to \code{object$term} (and \code{object$by}). The \code{by} variable is the last element.
#' @param knots IGNORED!
#'
#' @return An object of class \code{dm.smooth}. In addition to the usual elements of a smooth class documented under \code{\link{smooth.construct}}, this object will contain an element...
#'
#' @section Details:
#' The constructor is not normally called directly, but is rather used internally by \code{\link{gam}}. To use for basis setup it is recommended to use \code{\link{smooth.construct2}}.
#'
#' The basis dimension \code{k} will be used as the truncation for the multidimensional scaling
#'
#' When specifying the model extra arguments must be supplied by the \code{xt} 
#' argument.
#' \tabular{ll}{
#'   \code{realdata} \tab the actual data to use for the model, usual args are ignored\cr
#'   \code{dist_fn} \tab distance function, takes one arg a \code{data.frame} or \code{matrix}, returns a square distance matrix with \code{nrow(arg)} rows and cols.
#' }
#'
#' NOTE: only 1 krpcr smoother can be included in a model!
#'
#' @author David L Miller, based on code from Lan Huo and Phil Reiss
smooth.construct.krpcr.smooth.spec <- function(object,data,knots){
  
  
  # all the extra stuff gets put in object$xt
  # distance matrix
  D <- object$xt$dist_fn(object$xt$realdata)
  
  # projection dimension
  pdim <- object$bs.dim
  
  ## do some input checking
  # either K or D must be supplied
  if(is.null(D)) {
    stop("You must supply a distance matrix!")
  }
  # default to fast cmdscale
  if(is.null(object$xt$fastcmd)){
    object$xt$fastcmd <- TRUE
  }

  ## if K not supplied then compute from D?
  #if(is.null(K) & !is.null(D)) {
  #  K <- d2k(D, cailliez = cailliez, truncate = truncate)
  #}
  
  # what do cmdscale options mean?!
  # k     - dimension of MDS projection
  # eig   - return eigenvalues
  # x.ret - return (double centred distance matrix)
  # add   - add a constant so D is Euclidean (cov() gives -ve
  #         values, which is not a property of a distance.
  if(object$xt$fastcmd){
    # use lanczos for the eigendecomposition
    mds.obj <- cmdscale_lanczos(D, k=pdim, eig=TRUE, x.ret=TRUE, add=TRUE)
  }else{
    mds.obj <- cmdscale(D, k=pdim, eig=TRUE, x.ret=TRUE, add=TRUE)
  }
  
  ## four required additions to the return object:
  # model matrix
  object$X <- mds.obj$points
  colnames(object$X) <- paste0("krpcr_", 1:ncol(object$X))
  # penalty matrix
  object$S <- list(diag(nrow = pdim))
  # penalty rank
  object$rank <- array(pdim, dim=c(1,1))
  # null space dimension
  object$null.space.dim <- 0
  
  # set the label (for plots and summary)
  object$label <- object$term
  
  # now reset the terms so we include ALL possible
  #variables (though we limit to pdim in reality)
  object$term <- paste0("krpcr_", 1:ncol(object$xt$realdata))
  
  # store dimension
  object$dim <- pdim
  
  ## extra options
  # don't allow tensor products
  object$te.ok <- 0
  # probably best not to plot this with plot.gam
  # (what would the x axis be?)
  object$plot.me <- FALSE
  
  # see ?smooth.construct for what these mean!
  object$C <- array(dim=c(0, 1))
  object$side.constrain <- FALSE
  
  object$no.rescale <- TRUE
  
  # save mds object returned by cmdscale
  object$xt$mds.obj <- mds.obj
  
  # give it some class
  class(object) <- "krpcr.smooth"
  return(object)
}
