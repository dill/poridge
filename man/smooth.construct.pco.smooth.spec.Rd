% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/smooth.construct.pco.smooth.spec.R
\name{smooth.construct.pco.smooth.spec}
\alias{pco}
\alias{smooth.construct.pco.smooth.spec}
\title{Build a PCoRR smoother}
\usage{
\method{smooth.construct}{pco.smooth.spec}(object, data, knots)
}
\arguments{
\item{object}{a smooth specification object, usually generated by a term \code{s(..., bs="pco", ...)}. Note that \code{xt} object is required, see Details, below.}

\item{data}{a list containing just the data.}

\item{knots}{IGNORED!}
}
\value{
An object of class \code{pco.smooth}. The resulting object has an \code{xt} element which contains details of the multidimensional scaling, which may be interesting.
}
\description{
Build a basis and (ridge) penalty that allows one to regress the response on leading principal coordinates defined by a relevant distance among the functional predictors.
}
\section{Details}{

The constructor is not normally called directly, but is rather used internally by \code{\link{gam}}. To use for basis setup it is recommended to use \code{\link{smooth.construct2}}.

The basis dimension \code{k} will be used as the truncation for the multidimensional scaling (so \code{k=9} will give a 9-dimensional MDS projection).

When specifying the model extra arguments must be supplied by the \code{xt} argument. Two forms are possible:

First supplying:
\itemize{
  \item \code{realdata} the actual data to use for the model, usual args are ignored\cr
  \item \code{dist_fn} distance function. It will take one argument: a \code{data.frame} or \code{matrix} of data locations and returns a square distance matrix with number of rows and columns equal to the number of rows in the data passed to it.
}
These will create a distance matrix to be projected.

Instead one may supply a distance matrix directly \code{D=...} .

\code{xt} also has the following options:
\itemize{
  \item \code{add} if \code{TRUE} then a constant is added to the distance matrix before the MDS is calculated, ensuring that the distances are non-negative. See \code{\link{cmdscale}} for details. (Default \code{FALSE}.)\cr
   \item \code{fastcmd} should eigendecompositions of the distance matrix be calculated using \code{\link{slanczos}} (\code{fastcmd=TRUE}) or using \code{\link{cmdscale}} (\code{fastcmd=FALSE})? In the former case eigendecompositions used for the multidimensional scaling will use a Lanczos iteration to calculate the first \code{k} eigenvalues/vectors quickly.
}
}
\examples{
# a simulated example

require(poridge)
require(dtw)

## First generate the data
Xnl <- matrix(0, 30, 101)
set.seed(813)
tt <- sort(sample(1:90, 30))
for(i in 1:30){
  Xnl[i, tt[i]:(tt[i]+4)] <- -1
  Xnl[i, (tt[i]+5):(tt[i]+9)] <- 1
}
X.toy <- Xnl + matrix(rnorm(30*101, ,0.05), 30)
y.toy <- tt + rnorm(30, 0.05)
y.rainbow <- rainbow(30, end=0.9)[(y.toy-min(y.toy))/
                                   diff(range(y.toy))*29+1]

## Display the toy data
par(mfrow=c(2, 2))
matplot((0:100)/100, t(Xnl[c(4, 25), ]), type="l", xlab="t", ylab="",
        ylim=range(X.toy), main="Noiseless functions")
matplot((0:100)/100, t(X.toy[c(4, 25), ]), type="l", xlab="t", ylab="",
        ylim=range(X.toy), main="Observed functions")
matplot((0:100)/100, t(X.toy), type="l", lty=1, col=y.rainbow, xlab="t",
        ylab="", main="Rainbow plot")

## Obtain DTW distances
D <- dist(X.toy, method="dtw", window.type="sakoechiba", window.size=5)

## Compare PC vs. PCo ridge regression

# matrix to store results
GCVmat <- matrix(NA, 15, 2)
# dummy response variable
dummy <- rep(1,30)

# loop over possible projection dimensions
for(k. in 1:15){
  # fit models
  m1 <- gam(y.toy ~ s(dummy, bs="pco", k=k.,
            xt=list(realdata=X.toy, dist_fn=dist)), method="REML")
  m2 <- gam(y.toy ~ s(dummy, bs="pco", k=k., xt=list(D=D)), method="REML")
  # calculate and store GCV scores
  GCVmat[k., ] <- length(y.toy) * c(sum(m1$residuals^2)/m1$df.residual^2,
                   sum(m2$residuals^2)/m2$df.residual^2)
}

## plot the GCV scores per dimension for each model
matplot(GCVmat, lty=1:2, col=1, pch=16:17, type="o", ylab="GCV",
        xlab="Number of principal components / coordinates",
        main="GCV score")
legend("right", c("PCR", "DTW-based PCoR"), lty=1:2, pch=16:17)
}
\author{
David L Miller, based on code from Lan Huo and Phil Reiss
}

